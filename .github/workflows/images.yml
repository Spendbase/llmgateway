name: images

on:
  release:
    types: [published]
  push:
    branches:
      - main
      - hotfix
  pull_request:
    paths:
      - "**/package.json"
      - "**/tsconfig.json"
      - "pnpm-lock.yaml"
      - "infra/**"
      - ".github/workflows/images.yml"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set-tag.outputs.IMAGE_TAG }}
      new_version: ${{ steps.set-tag.outputs.NEW_VERSION }}
      bump_type: ${{ steps.set-tag.outputs.BUMP_TYPE }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set image tag
        id: set-tag
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Fetch all tags
            git fetch --tags --force

            # Get latest semantic version tag (v*.*.*)
            LATEST_TAG=$(git tag -l "v*.*.*" | sort -V | tail -n1)

            if [[ -z "$LATEST_TAG" ]]; then
              # No tags exist, start from v0.0.0
              CURRENT_VERSION="0.0.0"
            else
              # Strip 'v' prefix
              CURRENT_VERSION="${LATEST_TAG#v}"
            fi

            # Parse current version
            IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR="${VERSION_PARTS[0]}"
            MINOR="${VERSION_PARTS[1]}"
            PATCH="${VERSION_PARTS[2]}"
            
            # Check commit message for version bump type
            if [[ "$COMMIT_MSG" =~ \[major\]|BREAKING\ CHANGE: ]]; then
              # Major version bump (e.g., 1.2.3 -> 2.0.0)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major"
            elif [[ "$COMMIT_MSG" =~ \[minor\]|^feat:|^feat\( ]]; then
              # Minor version bump (e.g., 1.2.3 -> 1.3.0)
              MINOR=$((MINOR + 1))
              PATCH=0
              BUMP_TYPE="minor"
            else
              # Patch version bump (e.g., 1.2.3 -> 1.2.4)
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch"
            fi

            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"

            echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=v${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "BUMP_TYPE=${BUMP_TYPE}" >> $GITHUB_OUTPUT
            echo "Build version: v${NEW_VERSION} (was: v${CURRENT_VERSION}, bump: ${BUMP_TYPE})"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            echo "IMAGE_TAG=pr-${SHORT_SHA}" >> $GITHUB_OUTPUT
          else
            # Release event - use release tag name
            if [[ ! "${{ github.event.release.tag_name }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9_-]+)*$ ]]; then
              echo "Invalid tag name for Docker: ${{ github.event.release.tag_name }}"
              exit 1
            fi
            echo "IMAGE_TAG=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: setup
    if: |
      (github.event_name != 'pull_request' && needs.setup.result == 'success') ||
      (github.event_name == 'pull_request')
    runs-on: k8s-arm64
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        app: [api, gateway, playground, ui, docs, worker, admin]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          docker build \
            -f infra/split.dockerfile \
            --target ${{ matrix.app }} \
            --build-arg APP_VERSION=${{ github.event_name == 'pull_request' && 'pr-test' || needs.setup.outputs.image_tag }} \
            -t $ECR_REGISTRY/llmgateway/${{ matrix.app }}:$IMAGE_TAG \
            ${{ github.event_name != 'pull_request' && '--push' || '' }} \
            .

      # - name: Tag as latest (non-PR only)
      #   if: github.event_name != 'pull_request'
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
      #   run: |
      #     docker tag $ECR_REGISTRY/llmgateway/${{ matrix.app }}:$IMAGE_TAG $ECR_REGISTRY/llmgateway/${{ matrix.app }}:latest
      #     docker push $ECR_REGISTRY/llmgateway/${{ matrix.app }}:latest
      #

  # test:
  #   runs-on: k8s-arm64
  #   needs:
  #     - setup
  #     - build
  #   if: |
  #     always() &&
  #     needs.setup.result == 'success' &&
  #     needs.build.result == 'success'
  #   permissions:
  #     contents: read
  #     packages: read
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v6
  #
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v1
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: eu-central-1
  #
  #     - name: Login to Amazon ECR
  #       id: login-ecr
  #       uses: aws-actions/amazon-ecr-login@v1
  #
  #     - name: Pull Docker images for testing
  #       if: github.event_name != 'pull_request'
  #       env:
  #         ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
  #         IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
  #       run: |
  #         for app in api gateway playground ui docs worker admin; do
  #           echo "Pulling $app image..."
  #           docker pull $ECR_REGISTRY/llmgateway/$app:$IMAGE_TAG
  #         done
  #
  # - name: Test split Docker images
  #   env:
  #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
  #     IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
  #   run: |
  #     chmod +x .github/test-split-docker.sh
  #     .github/test-split-docker.sh $ECR_REGISTRY/llmgateway $IMAGE_TAG
  #
  create-tag-and-release:
    runs-on: ubuntu-latest
    needs:
      - setup
      - build
    if: github.event_name == 'push' && needs.build.result == 'success'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Create and push tag
        env:
          NEW_VERSION: ${{ needs.setup.outputs.new_version }}
          BUMP_TYPE: ${{ needs.setup.outputs.bump_type }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          TAG_NAME="v${NEW_VERSION}"

          # Get the previous tag for changelog
          PREV_TAG=$(git tag -l "v*.*.*" | sort -V | tail -n1)

          # Create annotated tag
          TAG_MESSAGE="Release ${TAG_NAME} (${BUMP_TYPE} bump)

          Build #${{ github.run_number }}
          Commit: ${{ github.sha }}
          Branch: ${{ github.ref_name }}"

          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"

          # Push tag
          git push origin "$TAG_NAME"

          echo "✅ Created and pushed tag: $TAG_NAME"
          echo "PREV_TAG=${PREV_TAG}" >> $GITHUB_ENV
          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_ENV

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from commits since last tag
          if [[ -n "$PREV_TAG" ]]; then
            CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges | head -20)
          fi

          # Create release notes
          cat > release-notes.md <<EOF
          ## What's Changed

          ${CHANGELOG}

          ## Docker Images

          All images have been built and pushed to ECR with tag \`${TAG_NAME}\`:
          - \`llmgateway/api:${TAG_NAME}\`
          - \`llmgateway/gateway:${TAG_NAME}\`
          - \`llmgateway/ui:${TAG_NAME}\`
          - \`llmgateway/playground:${TAG_NAME}\`
          - \`llmgateway/docs:${TAG_NAME}\`
          - \`llmgateway/worker:${TAG_NAME}\`
          - \`llmgateway/admin:${TAG_NAME}\`

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG_NAME}
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release using gh CLI
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --notes-file release-notes.md \
            --verify-tag

          echo "✅ Created GitHub release: $TAG_NAME"
